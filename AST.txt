3GROUP - 10
ADITYA MITHAL                 2017A7PS0157P
        MAYANK JAIN                        2017A7PS0179P
        ATMADEEP BANERJEE                2017A7PS0101P
        UJJWAL GANDHI                2017A7PS0143P


ATTRIBUTES        
	MEANING
	* node
	* It is the address pointing to the memory location of the corresponding node in the AST.
	* address
	* It is the address pointing to the memory location of the corresponding node in the original Parse Tree
	* label
	* Name of the construct representing the root of the subtree in the parsee tree.
	



FUNCTIONS
	MEANING
	* newNode(label, childrenNode...)
	* Creates a newNode with a label name and a pointer to each of the child Node and returns a pointer to it.
	* pushListNode(currentNode, nextNode)
	* Takes a pointer to a linkedList as nextNode and the node to be inserted as currentNode, inserts the currentNode at the starting of the LinkedList and returns a pointer to its head.
	





        SEMANTIC RULES


1. program -> moduledeclarations othermodules drivermodule othermodules1
   1. program.node = newNode(‘PROGRAM’, moduledeclarations.node, othermodules.node, drivermodule.node, othermodules1.node)
   2. free(moduledeclarations.address)
   3. free(othermodules.address)
   4. free(drivermodule.address)
   5. free(othermodules1.address)
2. moduledeclarations -> moduledeclaration moduledeclarations1
   1. moduledeclarations.node = pushListNode(moduledeclaration.node, moduledeclarations1.node)
   2. free(moduledeclarations1.address)
   3. free(moduledeclaration.address)
3. moduledeclarations -> EPSILON
   1. moduledeclarations.node = NULL
4. moduledeclaration -> DECLARE MODULE ID SEMICOL
   1. moduledeclaration.node = ID.address
5. othermodules -> module othermodules1
   1. othermodules.node = pushListNode(module.node, othermodules1.node)
   2. free(module.address)
   3. free(othermodules1.address)
6. othermodules -> EPSILON
   1. othermodules.node = NULL
7. drivermodule -> DRIVERDEF DRIVER PROGRAM DRIVERENDDEF moduledef
   1. module.node = moduledef.node
   2. free(moduledef.address)
8. module -> DEF MODULE ID ENDDEF TAKES INPUT SQBO inputplist SQBC SEMICOL ret moduledef
   1. module.node = newNode(“MODULE”, ID.address, inputplist.node, ret.node, moduledef.node)
   2. free(moduledef.address)
   3. free(inputplist.address)
   4. free(ret.address)
9. ret -> RETURNS SQBO outputplist SQBC SEMICOL
   1. ret.node = outputplist.node
   2. free(outputplist.address)
10. ret -> EPSILON
   1. ret.node = NULL
11. inputplist -> ID COLON datatype n1
   1. inputplist.node = pushListNode(newNode(datatype.node, ID.address, n1.node)
   2. free(datatype.address)
   3. free(n1.address)
12. n1 -> COMMA ID COLON datatype n11
   1. n1.node = pushListNode(newNode(datatype.node, ID.address, n11.node)
   2. free(datatype.address)
   3. free(n11.address)
13. n1 -> EPSILON
   1. n1.node = NULL
14. outputplist -> ID COLON type n2
   1. outputplist.node = pushListNode(newNode(type.label, ID.address), n2.node)
   2. free(n2.address)
15. n2 -> COMMA ID COLON type n21
   1. n2.node = pushListNode(newNode(type.label, ID.address), n21.node)
   2. free(n21.address)
16. n2 -> EPSILON
   1. n2.node = NULL
17. datatype -> INTEGER
   1. datatype.node = INTEGER.address
18. datatype -> REAL
   1. datatype.node = REAL.address
19. datatype -> BOOLEAN
   1. datatype.node = BOOLEAN.address
20. datatype -> ARRAY SQBO rangearrays SQBC OF type
   1. rangearrays.inh = type.label
   2. datatype.node = rangearrays.node
   3. free(rangearrays.address)
21. rangearrays -> ind RANGEOP ind1
   1. rangearrays.node = newNode(rangearrays.inh, ind.node, ind1.node)
   2. free(ind.address)
   3. free(ind1.address)
22. type -> INTEGER
   1. type.label = ‘INTEGER’
23. type -> REAL
   1. type.label = ‘REAL’
24. type -> BOOLEAN
   1. type.label = ‘BOOLEAN’
25. moduledef -> START statements END
   1. moduledef.node = statements.node
   2. free(statements.address)
26. statements -> statement statements1
   1. statements.node = pushListNode(statement.node, statements1.node)
27. statements -> EPSILON
   1. statements.node = NULL
28. statement -> iostmt
   1. statement.node = iostmt.node 
   2. free(iostmt.address)
29. statement -> simplestmt
   1. statement.node = simplestmt.node
   2. free(simplestmt.address)
30. statement -> declarestmt
   1. statement.node = declarestmt.node
   2. free(declarestmt.address)
31. statement -> conditionalstmt
   1. statement.node = conditionalstmt.node
   2. free(conditionalstmt.address)
32. statement -> iterativestmt
   1. statement.node = iterativestmt.node
   2. free(iterativestmt.address)
33. iostmt -> GET_VALUE BO ID BC SEMICOL
   1. iostmt.node = newNode(“getstmt”,ID.address)
34. iostmt -> PRINT BO var BC SEMICOL
   1. iostmt.node = newNode(“printstmt”, var.node)
35. boolconstt -> TRUE
   1. boolconstt.node = TRUE.address
36. boolconstt -> FALSE
   1. boolconstt.node = FALSE.address
37. varidnum -> ID whichid
   1. whichid.inh = ID.address
   2. varidnum.node = whichid.syn
   3. free(whichid.address)
38. varidnum -> NUM
   1. varidnum.node = NUM.address
39. varidnum -> RNUM
   1. varidnum.node = RNUM.address
40. var -> varidnum
   1. var.node = varidnum.node
   2. free(varidnum.address)
41. var -> boolconstt
   1. var.node = boolconstt.node
   2. free(boolconstt.address)
42. whichid -> SQBO ind SQBC
   1. whichid.node = newNode(“ArrElement”, whichid.inh, ind.syn)
   2. whichid.syn = whichid.node
   3. free(whichid.address) //wrong
   4. free(ind.address)
43. whichid -> EPSILON
   1. whichid.syn = whichid.inh
44. simplestmt -> assignstmt
   1. simplestmt.node = assignstmt.node
   2. free(assignstmt.address)
45. simplestmt -> modulereusestmt
   1. simplestmt.node = modulereusestmt.node
   2. free(modulereusestmt.address)
46. assignstmt -> ID whichstmt
   1. whichstmt.inh = ID.address
   2. assgnstmt.node = whichstmt.syn
   3. free(whichstmt.address)
47. whichstmt -> lvalueidstmt
   1. lvalueidstmt.inh = whichstmt.inh
   2. whichstmt.syn = lvalueidstmt.node
   3. free(lvalueidstmt.address)
48. whichstmt -> lvaluearrstmt
   1. lvaluearrstmt.inh= whichstmt.inh
   2. whichstmt.syn = lvaluearrstmt.node
   3. free(lvaluearrstmt.address)
49. lvalueidstmt -> ASSIGNOP expression SEMICOL
   1. lvalueidstmt.node = newNode(“assignstmt”, lvalueidstmt.inh, expression.node)
   2. free(expression.address)
50. lvaluearrstmt -> SQBO ind SQBC ASSIGNOP expression SEMICOL
   1. lvaluearrstmt.node = newNode(“assignstmt”, newNode(“arrayelement”,lvaluearrstmt.inh, ind.node), expression.node)
   2. free(expression.address)
   3. free(ind.address)
51. ind -> NUM
   1. ind.node = NUM.address
52. ind -> ID
   1. ind.node = ID.address
53. modulereusestmt -> optional USE MODULE ID WITH PARAMETERS idlist SEMICOL
   1. modulereusestmt.node = newNode(“modulereuse”, optional.node, ID.address, idlist.node)
   2. free(optional.address)
   3. free(idList.address)
54. optional -> SQBO idlist SQBC ASSIGNOP
   1. optional.node = idlist.node
   2. free(idlist.address)
55. optional -> EPSILON
   1. optional.node = NULL
56. idlist -> ID n3
   1. idlist.node = pushListNode(ID.address, n3.node)
   2. free(n3.address)
57. n3 -> COMMA ID n31
   1. n3.node = pushListNode(ID.address, n31.node)
   2. free(n31.address)
58. n3 -> EPSILON[a][b][c][d]
   1. n3.node = NULL
59. expression -> arithmeticorbooleanexpr
   1. expression.node = arithmeticorbooleanexpr.node
   2. free(arithmeticorbooleanexpr.address)
60. expression -> u
   1. expression.node = u.node
   2. free(u.address)
61. u -> op1 newnt
   1. u.node = newNode(op1.label, newnt.node)
   2. free(newnt.address)
62. newnt -> BO arithmeticexpr BC
   1. newnt.node = arithmeticexpr.node
   2. free(arithmeticexpr.address)
63. newnt -> varidnum
   1. newnt.node = varidnum.node
   2. free(varidnum.address)
64. arithmeticorbooleanexpr -> anyterm n7
   1. n7.inh = anyterm.node
   2. arithmeticorbooleanexpr.node = n7.syn
   3. free(anyterm.address)
   4. free(n7.address)
65. n7 -> logicalop anyterm n71
   1. n71.inh = newNode(logicalop.label, n7.inh, anyterm.node)
   2. n7.syn = n71.syn
   3. free(anyterm.address)
   4. free(n71.address)
66. n7 -> EPSILON
   1. n7.syn = n7.inh
67. anyterm -> arithmeticexpr n8
   1. anyterm.node = n8.syn
   2. n8.inh = arithmeticexpr.node
   3. free(n8.address)
   4. free(arithmeticexpr.address)
68. anyterm -> boolconstt
   1. anyterm.node = boolconstt.node
   2. free(boolconstt.address)
69. n8 -> relationalop arithmeticexpr
   1. n8.syn = newNode(relationalop.label, n8.inh, arithmeticexpr.node)
   2. free(arithmeticexpr.address)
   3. free(relationalop.address)
70. n8 -> EPSILON
   1. n8.syn = n8.inh
71. arithmeticexpr -> term n4
   1. arithmeticexpr.node = n4.syn
   2. n4.inh = term.node
   3. free(n4.address)
   4. free(term.address)
72. n4 -> op1 term n41
   1. n41.inh = newNode(op1.label, n4.inh, term.node)
   2. n4.syn = n41.syn
   3. free(term.address)
   4. free(n41.address)
   5. free(op1.address)
73. n4 -> EPSILON
   1. n4.syn = n4.inh
74. term -> factor n5
   1. term.node = n5.syn
   2. n5.inh = factor.node
   3. free(n5.address)
   4. free(factor.address)
75. n5 -> op2 factor n51
   1. n51.inh = newNode(op2.label, n5.inh, factor.node)
   2. n5.syn = n51.syn 
   3. free(factor.address)
   4. free(op2.address)
   5. free(n51.address)
76. n5 -> EPSILON
   1. n5.syn = n5.inh
77. factor -> BO arithmeticorbooleanexpr BC
   1. factor.node = arithmeticorbooleanexpr.node
   2. free(arithmeticorbooleanexpr.address)
78. factor -> varidnum
   1. factor.node = varidnum.node
   2. free(varidnum.address)
79. op1 -> PLUS
   1. op1.label = ‘+’
80. op1 -> MINUS
   1. op1.label = ‘-’
81. op2 -> MUL
   1. op2.label = ‘*’
82. op2 -> DIV
   1. op2.label = ‘/’
83. logicalop -> AND
   1. logicalop.label = ‘&’
84. logicalop -> OR
   1. logicalop.label = ‘|’
85. relationalop -> LT
   1. relationalop.label = ‘<’
86. relationalop -> LE
   1. relationalop.label = ‘<=’
87. relationalop -> GT
   1. relationalop.label = ‘>’
88. relationalop -> GE
   1. relationalop.label = ‘>=’
89. relationalop -> EQ
   1. relationalop.label = ‘:=’
90. relationalop -> NE
   1. relationalop.label = ‘!=’
91. declarestmt -> DECLARE idlist COLON datatype SEMICOL
   1. declarestmt.node = newNode(“declare”, idlist.node, datatype.node)
   2. free(idlist.address)
   3. free(datatype.address)
92. conditionalstmt -> SWITCH BO ID BC START casestmts dflt END
   1. conditionalstmt.node = newNode(“conditionalstmt”, ID.address, casestmts.node, dflt.node)
   2. free(casestmts.address)
   3. free(dflt.address)
93. casestmts -> CASE value COLON statements BREAK SEMICOL n9
   1. casestmts.node = pushListNode(newNode(‘CASE’, value.node, statements.node), n9.node)
   2. free(value.address)
   3. free(statements.address)
   4. free(n9.address)
94. n9 -> CASE value COLON statements BREAK SEMICOL n91
   1. n9.node = pushListNode(newNode(‘CASE’, value.node, statements.node), n91.node)
   2. free(value.address)
   3. free(statements.address)
   4. free(n91.address)
95. n9 -> EPSILON
   1. n9.node = NULL
96. value -> NUM
   1. value.node = NUM.address
97. value -> TRUE
   1. value.node = TRUE.address
98. value -> FALSE
   1. value.node = FALSE.address
99. dflt -> DEFAULT COLON statements BREAK SEMICOL
   1. dflt.node = statements.node
   2. free(statements.address)
100. dflt -> EPSILON
   1. dflt.node = NULL
101. iterativestmt -> FOR BO ID IN range BC START statements END
   1. iterativestmt.node = newNode(“iterativestmt”, ID.address, range.node, statements.node)
   2. free(range.address)
   3. free(statements.address)
102. iterativestmt -> WHILE BO arithmeticorbooleanexpr BC START statements END
   1. iterativestmt.node = newNode(“iterativestmt”, arithmeticorbooleanexpr.node, statements.node)
   2. free(arithmeticorbooleanexpr.address)
   3. free(statements.address)
103. range -> NUM RANGEOP NUM1
   1. range.node = newNode(“range”, NUM.address, NUM1.address)
[a]is null correct?
[b]YES
[c]_Marked as resolved_
[d]_Re-opened_
pdf